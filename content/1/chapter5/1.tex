在C++11之前，当为那些复制开销很大的成员实现getter时，我们有以下几种选择:\par

\begin{itemize}
	\item 传值返回
	\item 通过左值引用返回
\end{itemize}

让我们简单地讨论一下这些方案。\par

\hspace*{\fill} \par %插入空行
\textbf{5.1.1 传值返回}

一个按值返回的getter看起来是这样的(记住:不要使用const按值返回，否则禁用移动语义):\par

\begin{lstlisting}[caption={}]
class Person
{
private:
	std::string name;
public:
	...
	std::string getName() const {
		return name;
	}
};
\end{lstlisting}

这段代码是安全的，但每次获取name时，都可能复制name。\par

例如，只是检查是否有一个没名字的人会有很大的开销:\par

\begin{lstlisting}[caption={}]
std::vector<Person> coll;
...
for (const auto& person : coll) {
	if (person.getName().empty()) { // OOPS: copies the name
		std::cout << "found empty name\n";
	}
}
\end{lstlisting}

如果将此方法与返回引用的方法进行比较，可以看到按值返回字符串的版本的性能开销是引用的2到100倍(前提是名称的长度较大，这样SSO就没有帮助了)。对图像或数千个元素的集合的成员可能更糟糕。在这种情况下，getter通常返回(const)引用以提高性能。\par

\hspace*{\fill} \par %插入空行
\textbf{5.1.2 引用返回}

通过引用返回的getter看起来像这样:\par

\begin{lstlisting}[caption={}]
class Person
{
private:
	std::string name;
public:
	...
	const std::string& getName() const {
		return name;
	}
};
\end{lstlisting}

这样更快，但不安全，因为调用者必须确保返回的引用引用的对象的生命足够长。实际上，使用返回引用值比原始对象的时间长的话，会有生命周期上的风险。\par

踩入这种陷阱的一种是使用基于范围的for循环，如下所示:\par

\begin{lstlisting}[caption={}]
for (char c : returnPersonByValue().getName()) { // OOPS: undefined behavior
	if (c == ' ') {
		...
	}
}
\end{lstlisting}

注意，在循环头的右边有一个函数，它返回一个我们用getter引用的临时对象。但是，定义了基于范围的for循环，使上面的代码等价于以下代码:\par

\begin{lstlisting}[caption={}]
reference range = returnPersonByValue().getName();
// OOPS: returned temporary object destroyed here
for (auto pos = range.begin(), end = range.end(); pos != end; ++pos) {
	char c = *pos;
	if (c == ' ') {
		...
	}
}
\end{lstlisting}

在开始迭代之前，我们初始化reference1，我们必须使用传递的范围两次(一次调用begin()，一次为其调用end())，并希望避免创建副本(这可能代价很高，甚至不可能)。一般来说，引用会延长所引用内容的生命周期。在本例中，range并不引用由returnPersonByValue()返回的Person，而range指向getName()的返回值，它是对返回的Person的引用。因此，range扩展了引用的生命周期，而不是引用所引用的临时对象的生命周期。因此，在第一个语句的末尾，返回的临时对象将被销毁，并且在遍历名称的字符时使用对已销毁对象名称的引用。\par

在最好的情况下，我们在这里得到一个核心转储(段错误)，这样我们就可以看到出现了明显的错误。最坏的情况是，一旦发布了软件，就会出现致命的未定义行为。\par

如果getter按值返回名称，这样的代码就不会有问题。这样，range将扩展名称副本的生存期，以便我们可以使用该名称直到range的生存期结束。\par

\hspace*{\fill} \par %插入空行
\textbf{5.1.3 使用移动语义解决困境}

通过移动语义，我们现在有了解决这个困境的方法。如果这样做是安全的，我们可以通过引用返回。如果可能遇到生命周期问题，我们可以通过值返回。\par

方法如下:\par

\begin{lstlisting}[caption={}]
class Person
{
private:
	std::string name;
public:
	...
	std::string getName() && { // when we no longer need the value
		return std::move(name); // we steal and return by value
	}
	const std::string& getName() const& { // in all other cases
		return name; // we give access to the member
	}
};
\end{lstlisting}

用不同的引用限定符重载getter，方法与重载带有\&\&和const\&形参的函数相同:\par

\begin{itemize}
	\item 带有\&\&限定符的版本是有不再需要值的对象时使用(一个即将死亡的对象或用\textit{std::move()}标记的对象)。
	\item 带有const\&限定符的版本用于所有其他情况。它总是合适的，但只是在我们无法获得\&\&版本时的备选方案。因此，如果有一个不会销毁的对象或没标记为\textit{std::move()}，则使用此函数。
\end{itemize}

现在的性能和安全性都很好:\par

\begin{lstlisting}[caption={}]
Person p{"Ben"};
std::cout << p.getName(); // 1) fast (returns reference)
std::cout << returnPersonByValue().getName(); // 2) fast (uses move())

std::vector<Person> coll;
...
for (const auto& person : coll) {
	if (person.getName().empty()) { // 3) fast (returns reference)
		std::cout << "found empty name\n";
	}
}

for (char c : returnPersonByValue().getName()) { // 4) safe and fast (uses move())
	if (c == ' ') {
		...
	}
}
\end{lstlisting}

语句1)和3)使用const\&的版本，因为有一个对象没有被\textit{std::move()}标记。语句2)和4)使用\&\&的版本，因为我们为一个临时对象调用getName()。因为临时对象即将销毁，getter可以将成员名移出作为返回值，这意味着我们不必为返回值分配新的内存，我们可以窃取了成员的值。\par

您可能还记得，return语句不应该使用\textit{std::move()}来返回已经销毁的局部对象。在本例中，我们不返回任何局部对象，而是返回一个成员，其生存期不以成员函数的结束为结束。\par

\hspace*{\fill} \par %插入空行
\textbf{\textit{std::move()}用于成员函数}

请注意，这个特性意味着即使在调用成员函数时也可以使用\textit{std::move()}。例如:\par

\begin{lstlisting}[caption={}]
void foo()
{
	Person p{ ... };
	...
	coll.push_back(p.getName()); // calls getName() const&
	...
	coll.push_back(std::move(p).getName()); // calls getName() && (OK, p no longer used)
}
\end{lstlisting}

使用getName()时，使用std::move()将提高程序的性能。不返回对const std::string的引用(只能复制)，返回值是作为非const字符串返回的p的移动名，因此push\_back()可以使用移动语义将其移动到coll中。通常，在这个调用之后，p处于有效但未定义的状态。\par

关于在C++标准库中使用此特性的示例，请参见class std::optional<>。\par
















