noexcept在C++11中引入是为了解决在vector中重新分配元素时不能使用移动语义的问题。\par

原则上，现在可以用noexcept(条件式)标记每个函数。这不仅有助于像vector重新分配这样的情况(注意，移动构造函数可能会调用其他需要noexcept保证的函数)，而且还有助于编译器优化代码，因为不需要生成代码来处理异常。所以问题是，哪里应该使用noexcept?\par

对于C++11标准库，我们会急于确定将noexcept放在哪里(重新分配问题很晚才发现，noexcept的最终语义在发布C++11的那一周才解释清楚)。因此，遵循http://wg21.link/n3279中提出的一种相当保守的方法，这对代码也可能是一个有用的指导方针。大致来说，指导方针是:\par

\begin{itemize}
	\item 每个库的工作组同意不能抛出异常，且具有“广泛契约”的库函数(即，由于一个前提条件而没有指定未定义的行为)都应该被标记为“无条件的noexcept”。
	\item 如果库中的交换函数、移动构造函数或移动赋值操作符是“条件宽松”的(即，可以通过应用noexcept操作符保证不抛出异常)，则应将其标记为有条件的noexcept。任何其他函数都不应该使用条件noexcept。
	\item 任何标准库析构函数都不应该抛出异常，应该使用隐式提供的(非抛出的)异常规范。
	\item 为兼容C代码而设计的库函数，可以标记为无条件的noexcept。
\end{itemize}

下面的例子阐明了第一项的意思:\par

\begin{itemize}
	\item 对于容器和字符串，成员函数empty()和clear()标记为noexcept，因为没有有用的方法来实现它们并抛出它们。
	\item vector和string的索引操作符不会被标记为noexcept，即使在正确使用时它保证不会抛出异常。然而，当传递无效索引时，我们有未定义的行为和实现任何想做的事情。不使用noexcept来声明时，这些实现可能会在这种情况下抛出异常。
\end{itemize}

第二项是在实现移动语义时应该遵循的指导原则。我们建议只在实现移动构造函数、移动赋值操作符或swap()函数时，使用条件noexcept。对于所有其他函数，通常不值得考虑详细的条件，您可能会透露太多的实现细节。\par

对于http://wg21.link/p0884，我们添加了包装类型也应该有条件noexcept的声明:\par

\begin{itemize}
	\item 如果标准库类型具有包装语义，以提供与底层类型相同的行为，则默认构造函数、复制构造函数和复制赋值操作符应有条件地标记为noexcept，而底层异常规范仍然有效。
\end{itemize}

最后，请注意，根据规则，任何析构函数都总是隐式声明为noexcept。\par

代码的结果如下:\par

\begin{itemize}
	\item 应该实现移动构造函数、移动赋值操作符和一个带有noexcept(条件)的swap()函数。
	\item 对于所有其他函数，在你知道它们不能抛出异常时，就使用无条件的noexcept。
	\item 析构函数不需要noexcept规范。
\end{itemize}







